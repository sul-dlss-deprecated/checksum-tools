#!/usr/bin/env ruby

require 'rubygems'
begin
  require 'bundler/setup'
rescue LoadError
  # We'll try to run without bundler
end
require 'checksum-tools'
require 'optparse'
require 'progressbar'
require 'yaml'

DEFAULT_OPTIONS = {
  :action => 'verify',
  :digests => [],
  :filemasks => [],
  :progress => true,
  :exclude => [],
  :extension => '.digest',
  :overwrite => false,
  :recursive => false
}

@pbar = nil
def progress(filename, size, pos)
  unless size.nil?
    if pos == -1
      @pbar.finish unless @pbar.nil?
      @pbar = nil
    else
      if @pbar.nil?
        @pbar = ProgressBar.new(File.basename(filename), size)
      end
      @pbar.set(pos)
    end
  end
end

def generate(tool, options)
  tool.create_digest_files(options[:dir],options[:filemasks]) do |filename, size, pos|
    progress(filename, size, pos) if options[:progress]
  end
end

def verify(tool, options)
  tool.verify_digest_files(options[:dir],options[:filemasks]) do |filename, size, pos, result|
    if result.nil?
      progress(filename, size, pos) if options[:progress]
    else
      progress(filename, -1, -1) if options[:progress]
      result.delete_if { |k,v| v == true }
      if result.length == 0
        print "PASS"
      else
        print "FAIL [#{result.keys.join(',')}]"
      end
      puts " #{filename}"
    end
  end
end

def make_options(user_options)
  options = DEFAULT_OPTIONS.merge(user_options)
  options[:filemasks] << '*' if options[:filemasks].length == 0
  options[:digests] << :md5 if options[:digests].length == 0
  options[:digests].uniq!
  options[:filemasks].uniq!
  options[:exclude].uniq!
  return options
end

def tool_for(user_options)
  options = make_options(user_options)
  args = options[:digests]
  args += [Hash[options.select { |k,v| [:exclude,:extension,:overwrite,:recursive].include?(k) }]]

  if remote = options[:remote] and remote[:host]
    Checksum::Tools::Remote.new(remote[:host],remote[:user],*args)
  else
    Checksum::Tools::Local.new(*args)
  end
end

def parse_path(path)
  user,host,dir = path.to_s.scan(/^(?:(.+)@)?(?:(.+):)?(?:(.+))?$/).flatten
  dir ||= '.'
  result = { :remote => { :user => user, :host => host }, :dir => dir }
  return result
end

VALID_ACTIONS = ['generate','verify']

config_file = File.join(ENV['HOME'], '.checksum-tools')
config_file_options = begin
  YAML.load(File.read(config_file))
rescue
  {}
end

cmdline_options = {}
dry_run = false

optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} [options] [path]"

  opts.on('-a', '--action ACTION', VALID_ACTIONS, "Specify action to take", "#{VALID_ACTIONS.join('|')}") do |action|
    cmdline_options[:action] = action
  end
  
  opts.on('-c', '--config FILE', "Load configuration from FILE") do |filename|
    config_file = filename
    config_file_options = YAML.load(File.read(config_file))
  end
  
  opts.on('-d', '--digest DIGEST', "Generate checksums of type DIGEST") do |digest|
    (cmdline_options[:digests] ||= []) << digest.to_sym
  end
  
  opts.on('-e', '--extension EXT', "File extension for digest files") do |ext|
    cmdline_options[:extension] = ext
  end
  
  opts.on('-f', '--filemask MASK', "Include files matching MASK") do |mask|
    (cmdline_options[:filemasks] ||= []) << mask
  end

  opts.on('-n', '--no-action', "Dry run; don't execute") do
    dry_run = true
  end
  
  opts.on('-o', '--overwrite', "Overwrite existing digest files") do
    cmdline_options[:overwrite] = true
  end
  
  opts.on('-q', '--quiet', "Hide the progress bar") do
    cmdline_options[:progress] = false
  end
  
  opts.on('-r', '--recursive', "Recurse into subdirectories") do
    cmdline_options[:recursive] = true
  end
  
  opts.on('-x', '--exclude MASK', "Exclude files matching MASK") do |mask|
    cmdline_options[:exclude] << mask
  end

  opts.on_tail('-D', '--digest-types', "Show digest types") do
    cmdline_options.merge!(parse_path(ARGV.pop))
    puts "Available digest types for #{cmdline_options[:remote][:host] || 'local system'}:"
    puts tool_for(cmdline_options).digests.join(' ')
    exit
  end
  
  opts.on_tail('-v', '--version', "Print version and exit") do
    puts "checksum-tools #{Checksum::Tools::VERSION}"
    exit
  end
  
  opts.on_tail('-h', '--help', "Show this help message") do
    puts opts
    exit
  end
end

optparse.parse!
cmdline_options.merge!(parse_path(ARGV.pop))
options = make_options(config_file_options.merge(cmdline_options))

if (options[:extension] !~ /[A-Za-z0-9]/) or (options[:dir].nil?)
  puts optparse
  exit
end

if dry_run
  puts "Defaults loaded from #{config_file}"
  puts YAML.dump(options)
  exit
end

tool = tool_for(options)
case options[:action]
when 'generate' then generate(tool, options)
when 'verify'   then verify(tool, options)
end